
#include "gtest/gtest.h"

#include <bigint_core.hpp>

using namespace std;

template <class InputIterator>
static bool ASSERT_BYTES_EQ(InputIterator f1, InputIterator l1, InputIterator f2, InputIterator l2) {

    for (; (f1 != l1) && (*f1 == 0x00); ++f1)
        ;

    for (; (f2 != l2) && (*f2 == 0x00); ++f2)
        ;

    for (; (f1 != l1) && (f2 != l2) && (*f1) == (*f2); ++f1, ++f2)
        ;

    return (f1 == l1) && (f2 == l2);
}

class BigintCoreTest : public ::testing::Test
{
	
protected:
	template<class T>
	void addition(const std::initializer_list<unsigned char>& a, const std::initializer_list<unsigned char>& b, const std::initializer_list<unsigned char>& expected)
	{
		auto aa = os2polynomial<T>(a.begin(), a.end());
		auto bb = os2polynomial<T>(b.begin(), b.end());
		auto ex = os2polynomial<T>(expected.begin(), expected.end());

		std::vector<T> actual(10);

		Cry_add<T>(begin(aa), end(aa), begin(bb), end(bb), end(actual));

		bool eq = ASSERT_BYTES_EQ(std::begin(ex), std::end(ex), std::begin(actual), std::end(actual));
		EXPECT_TRUE(eq);
	}

	template<class P, class OctetIterator>
	std::vector<P> os2polynomial(OctetIterator first, OctetIterator last)
	{
		std::reverse_iterator<OctetIterator> rfirst(last), rend(first);

		auto noctets = std::distance(rfirst, rend);
		auto nwords = noctets / sizeof(P);
		if (noctets % sizeof(P))
		{
			++nwords;
		}

		std::vector<P> dst(nwords);
		auto result = dst.rbegin();

		P word(0);
		size_t cnt(0);
		for (; rfirst != rend; ++rfirst)
		{
			word = (static_cast<P>(*rfirst) << cnt * 8) | word;
			++cnt;
			if (cnt == sizeof(P))
			{
				*result++ = word;
				word = 0;
				cnt = 0;
			}
		}

		if (word && cnt)
		{
			*result++ = word;
		}

		return dst;
	}
};

TEST_F(BigintCoreTest, Cry_add)
{
	addition<uint8_t>({ 0x00, 0xff }, { 0x00 }, { 0xff });
	addition<uint8_t>({ 0x00, 0x1a, 0x03 }, { 0x00, 0x00, 0x11 }, { 0x1a, 0x14 });
	addition<uint8_t>({ 0x00, 0xff, 0xff }, { 0x00, 0x00, 0xff, 0xff }, { 0x01, 0xFF, 0xFE });
	addition<uint8_t>({ 0x00, 0x00, 0x01, 0xfa, 0x14, 0xba, 0xce, 0x68, 0x02, 0x35 }, { 0x00, 0x00, 0x0a, 0x14, 0x05, 0xf5, 0xef, 0x38, 0x2a, 0x14 }, { 0x0c, 0x0e, 0x1a, 0xb0, 0xbd, 0xa0, 0x2c, 0x49 });
	addition<uint8_t>({ 0x10 }, { 0xff, }, { 0x01, 0x0f });
	addition<uint8_t>({ 0xff, 0xff, 0xff, 0xff, 0xff }, { 0x01, }, { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00 });

	addition<uint16_t>({ 0x00, 0xff }, { 0x00 }, { 0xff });
	addition<uint16_t>({ 0x00, 0x1a, 0x03 }, { 0x00, 0x00, 0x11 }, { 0x1a, 0x14 });
	addition<uint16_t>({ 0x00, 0xff, 0xff }, { 0x00, 0x00, 0xff, 0xff }, { 0x01, 0xFF, 0xFE });
	addition<uint16_t>({ 0x00, 0x00, 0x01, 0xfa, 0x14, 0xba, 0xce, 0x68, 0x02, 0x35 }, { 0x00, 0x00, 0x0a, 0x14, 0x05, 0xf5, 0xef, 0x38, 0x2a, 0x14 }, { 0x0c, 0x0e, 0x1a, 0xb0, 0xbd, 0xa0, 0x2c, 0x49 });
	addition<uint16_t>({ 0x10 }, { 0xff, }, { 0x01, 0x0f });
	addition<uint16_t>({ 0xff, 0xff, 0xff, 0xff, 0xff }, { 0x01, }, { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00 });

	addition<uint32_t>({ 0x00, 0xff }, { 0x00 }, { 0xff });
	addition<uint32_t>({ 0x00, 0x1a, 0x03 }, { 0x00, 0x00, 0x11 }, { 0x1a, 0x14 });
	addition<uint32_t>({ 0x00, 0xff, 0xff }, { 0x00, 0x00, 0xff, 0xff }, { 0x01, 0xFF, 0xFE });
	addition<uint32_t>({ 0x00, 0x00, 0x01, 0xfa, 0x14, 0xba, 0xce, 0x68, 0x02, 0x35 }, { 0x00, 0x00, 0x0a, 0x14, 0x05, 0xf5, 0xef, 0x38, 0x2a, 0x14 }, { 0x0c, 0x0e, 0x1a, 0xb0, 0xbd, 0xa0, 0x2c, 0x49 });
	addition<uint32_t>({ 0x10 }, { 0xff, }, { 0x01, 0x0f });
	addition<uint32_t>({ 0xff, 0xff, 0xff, 0xff, 0xff }, { 0x01, }, { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00 });
}
